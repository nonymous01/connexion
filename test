import base64
import json
import logging
import traceback

logger = logging.getLogger()
logger.setLevel(logging.INFO)

DEPLOYMENT_PREFIX = "deployment_"

def _check_input_params(invokation_params, expected_keys):
    if not all(k in invokation_params for k in expected_keys):
        raise RuntimeError(f"Invalid input params, expected keys={expected_keys}")

def _create_response(result: dict) -> dict:
    """
    Formats the final Lambda HTTP response.
    Returns status code 200 if success, otherwise 500.
    """
    return {
        "statusCode": 200 if isinstance(result, str) or result.get("success") else 500,
        "isBase64Encoded": False,
        "headers": {"Content-Type": "application/json"},
        "body": json.dumps(result, default=str),
    }

def _get_request_context_authorizer(event: dict) -> dict:
    """
    Retrieves authorizer claims from API Gateway requestContext.
    Returns an empty dict if requestContext or authorizer is missing.
    """
    node = event.get("context", event)
    request_context = node.get("requestContext", {})
    authorizer = request_context.get("authorizer", {})

    if not isinstance(authorizer, dict):
        logging.warning("No 'authorizer' found in 'requestContext'. Returning empty dict.")
        return {}
    return authorizer

def _get_params(event: dict) -> dict:
    """
    Parses and decodes the body payload if available.
    Handles both base64 and raw JSON bodies.
    """
    if "body" not in event and "body-json" not in event:
        return event

    body = event.get("body") or event.get("body-json")

    try:
        body = base64.b64decode(body, validate=True)
    except Exception:
        pass

    logger.info(f"Calculated 'body'={body}")

    if not body:
        return {}
    return body if isinstance(body, dict) else json.loads(body)

def _get_deployment_params(params: dict, prefix: str) -> tuple:
    """
    Splits parameters into client-specific and deployment-specific groups.
    Also adds workspace_id and workspace_name into deployment parameters.
    """
    deployment_params = {}
    client_params = {}

    for param in params:
        if param.startswith(prefix):
            deployment_params[param] = params[param]
        else:
            client_params[param] = params[param]

    deployment_params['deployment_workspace_id'] = params.get('workspace_id')
    deployment_params['deployment_workspace_name'] = params.get('workspace_name')

    return client_params, deployment_params

def dispatch_method(dispatch_table: dict, event: dict) -> dict:
    """
    Dispatches the appropriate method from the table based on the 'action' key.
    Merges authorization claims into invocation parameters.
    """
    invokation_params = _get_params(event)

    if not invokation_params:
        raise RuntimeError(f"Invalid input params, event={event}")

    logger.info(f"Invokation params: {invokation_params}")

    authorizer = _get_request_context_authorizer(event)
    logger.info(f"authorizer={authorizer}")

    if isinstance(authorizer, dict):
        invokation_params |= authorizer

    logger.info(f"Enriched _params: {invokation_params}")

    client_parameters, deployment_parameters = _get_deployment_params(invokation_params, DEPLOYMENT_PREFIX)

    logger.info(f"deployment_parameters : {deployment_parameters}")
    logger.info(f"client_parameters : {client_parameters}")

    result = {}
    try:
        _check_input_params(client_parameters, ["action", "workspace_id"])
        action = client_parameters["action"]
        result = dispatch_table[action](client_parameters, deployment_parameters)

    except Exception as e:
        logger.error(traceback.format_exc())
        result["success"] = False
        result["error"] = repr(e)

    logger.info(f"Finished dispatch with result={result}")
    return _create_response(result)
