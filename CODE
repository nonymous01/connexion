import ast
import json
import traceback
from datetime import date
from dateutil.relativedelta import relativedelta
import time
import logging

import utils.dispatcher_helper as dispatcher_helper
import utils.databricks_model_registry_helper as databricks_model_registry_helper
import utils.databricks_pipeline_helper as databricks_pipeline_helper

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def promote_model_registration(client_parameters: dict, deployment_parameters: dict):
    result = {}
    model_name = client_parameters["model_name"]
    model_version = client_parameters["model_version"]
    model_source = client_parameters["model_registry"]

    try:
        databricks_model_registry_helper.init(deployment_parameters)

        response = databricks_model_registry_helper.promote_model_registration(
            model_name, model_version, model_source
        )
       
        if response is not None:
            if 'message' in response:
                result["message"] = response["message"]
                result["success"] = False
            else:
                result["success"] = True
                result["status"] = "SUCCESS"

    except Exception as e:
        logger.error(f"Error promoting model", exc_info=True)
        result["success"] = False
        result["error"] = repr(e)
        result["status"] = "FAILURE"
    
    return result

def describe_model_registration(client_parameters: dict, deployment_parameters: dict):
    result = {}
    
    try:
        model_name = client_parameters["model_name"]
        model_version = client_parameters["model_version"]

        databricks_model_registry_helper.init(deployment_parameters)

        model_version_response = (
            databricks_model_registry_helper.get_model_registration(
                model_name, model_version
            )
        )

        if model_version_response:
            if model_version_response["status"] == "READY":
                result["status"] = "AVAILABLE"
            else:
                result["status"] = "UNAVAILABLE"

            result["model_name"] = model_name
            result["model_version"] = model_version
            result["model_source"] = model_version_response["source"]
            result["model_stage"] = model_version_response["current_stage"]
            result["success"] = True

        else:
            result["success"] = False
            result[
                "error"
            ] = f"Model {model_name} and {model_version} is not registered"

    except Exception as e:
        logger.error(f"Error retrieving model information", exc_info=True)
        result["success"] = False
        result["error"] = repr(e)

    return result

def get_latest_model_registration(
    client_parameters: dict, deployment_parameters: dict
):
    result = {}
    
    try:
        model_name = client_parameters["model_name"]
        stage = client_parameters.get("stage")

        databricks_model_registry_helper.init(deployment_parameters)

        result["model_name"] = model_name

        model_version_response = (
            databricks_model_registry_helper.get_latest_model_registration(
                model_name, stage
            )
        )

        if model_version_response:
            result["model_version"] = model_version_response["version"]
            result["model_stage"] = model_version_response["current_stage"]
            result["model_source"] = model_version_response["source"]
        else:
            result["model_version"] = 0

        result["success"] = True

    except Exception as e:
        logger.error(f"Error retrieving model information", exc_info=True)
        result["success"] = False
        result["error"] = repr(e)

    return result

def lambda_handler(event, context):
    start = time.perf_counter()
    dispatch_table = {
        "describe_model_registry": describe_model_registration,
        "get_latest_model_registration": get_latest_model_registration,
        "promote_model_registration": promote_model_registration,
    }

    # Log incoming event for debugging
    logger.info(f"Invokation params: {event}")

    # Check if this is a direct Lambda invocation or API Gateway event
    if "requestContext" not in event:
        # Direct invocation handling
        action = event.get("action")
        if not action:
            return {
                "success": False,
                "error": "No action specified in event"
            }
            
        if action not in dispatch_table:
            return {
                "success": False,
                "error": f"Unknown action: {action}"
            }
            
        # Call the appropriate function
        handler_func = dispatch_table[action]
        result = handler_func(
            client_parameters=event.get("client_parameters", {}),
            deployment_parameters=event.get("deployment_parameters", {})
        )
    else:
        # API Gateway request handling
        result = dispatcher_helper.dispatch_method(dispatch_table, event)
    
    duration = time.perf_counter() - start
    logger.info(f"handler completed in {duration:.3f} seconds")

    return result


Status: Succeeded
Test Event Name: TestModel

Response:
{
  "success": false,
  "error": "No action specified in event"
}

Function Logs:
START RequestId: 72616a21-1751-4d3a-b616-b2f6099cd8fc Version: $LATEST
[INFO]	2025-05-18T14:01:23.005Z	72616a21-1751-4d3a-b616-b2f6099cd8fc	Invokation params: {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}
END RequestId: 72616a21-1751-4d3a-b616-b2f6099cd8fc
REPORT RequestId: 72616a21-1751-4d3a-b616-b2f6099cd8fc	Duration: 15.50 ms	Billed Duration: 16 ms	Memory Size: 128 MB	Max Memory Used: 91 MB	Init Duration: 1737.39 ms

Request ID: 72616a21-1751-4d3a-b616-b2f6099cd8fc
