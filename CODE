./numpy/f2py/crackfortran.py:    vars = copy.copy(block['vars'])
./numpy/f2py/crackfortran.py:            neededvars = copy.copy(block['args'] + block['commonvars'])
./numpy/f2py/crackfortran.py:            neededvars = copy.copy(block['args'])
./numpy/f2py/func2subr.py:        rout = copy.copy(rout)
./numpy/f2py/func2subr.py:        rout = copy.copy(rout)
./numpy/f2py/rules.py:                nb1 = copy.deepcopy(nb)
./joblib/test/test_numpy_pickle.py:    if member == copy.deepcopy(member):
./pip/_internal/req/constructors.py:    result = copy.copy(ireq)
./pip/_vendor/requests/cookies.py:                self.set_cookie(copy.copy(cookie))
./pip/_vendor/requests/cookies.py:    new_jar = copy.copy(jar)
./pip/_vendor/requests/cookies.py:        new_jar.set_cookie(copy.copy(cookie))
./pip/_vendor/urllib3/util/timeout.py:        # We can't use copy.deepcopy because that will also create a new object
./sqlalchemy/sql/util.py:        ac = copy.copy(self)
./requests/cookies.py:                self.set_cookie(copy.copy(cookie))
./requests/cookies.py:    new_jar = copy.copy(jar)
./requests/cookies.py:        new_jar.set_cookie(copy.copy(cookie))
./sklearn/base.py:            return copy.deepcopy(estimator)
./sklearn/base.py:        new_object._metadata_request = copy.deepcopy(estimator._metadata_request)
./sklearn/base.py:        new_object._sklearn_output_config = copy.deepcopy(
./sklearn/metrics/_scorer.py:        _kwargs = copy.deepcopy(kwargs)
./sklearn/metrics/_scorer.py:                scorer = copy.deepcopy(_SCORERS[scoring])
./sklearn/metrics/_scorer.py:            requests.score = copy.deepcopy(estimator._metadata_request.score)
./sklearn/metrics/_scorer.py:                requests.score = copy.deepcopy(estimator._get_default_requests().score)
./sklearn/metrics/tests/test_dist_metrics.py:            vals = copy.deepcopy(vals)
./sklearn/metrics/_pairwise_distances_reduction/_datasets_pair.pyx.tp:            metric_kwargs = copy.copy(metric_kwargs)
./sklearn/tests/test_isotonic.py:    copy.copy(ir)
./sklearn/tests/test_metaestimators_metadata_routing.py:    assert a is copy.copy(a)
./sklearn/tests/test_metaestimators_metadata_routing.py:    assert a is copy.deepcopy(a)
./sklearn/tree/_classes.py:            criterion = copy.deepcopy(criterion)
./sklearn/tree/tests/test_tree.py:    for copy_func in [copy.copy, copy.deepcopy, _pickle_copy]:
./sklearn/mixture/tests/test_bayesian_mixture.py:        bgmm2 = copy.deepcopy(bgmm1)
./sklearn/mixture/tests/test_gaussian_mixture.py:        f = copy.deepcopy(g)
./pandas/io/formats/style.py:            setattr(styler, attr, copy.deepcopy(val) if deepcopy else val)
./pandas/io/formats/style.py:            "apply": copy.copy(self._todo),
./pandas/io/formats/style.py:            "table_styles": copy.copy(self.table_styles),
./pandas/io/formats/style.py:            "css": copy.copy(self.css),
./pandas/io/json/_normalize.py:        new_d = copy.deepcopy(d)
./pandas/io/pytables.py:        new_self = copy.copy(self)
./pandas/tests/io/formats/style/test_style.py:    s2 = copy.deepcopy(styler) if deepcopy else copy.copy(styler)  # make copy and check
./pandas/tests/io/formats/style/test_style.py:        copy.deepcopy(custom_styler) if deepcopy else copy.copy(custom_styler)
./pandas/tests/util/test_assert_numpy_array_equal.py:        other = copy.copy(nulls_fixture)
./pandas/tests/series/methods/test_equals.py:        right = copy.copy(right)
./pandas/core/window/rolling.py:        groupby_keys = copy.copy(self._grouper.names)
./pandas/core/window/rolling.py:        levels = copy.copy(self._grouper.levels)
grep: ./pandas/core/__pycache__/generic.cpython-312.pyc: binary file matches
./pandas/core/generic.py:        This is in contrast to `copy.deepcopy` in the Standard Library,
./pandas/core/resample.py:        self._timegrouper = copy.copy(parent._timegrouper)
./pandas/compat/pickle_compat.py:Unpickler.dispatch = copy.copy(Unpickler.dispatch)
./botocore/compat.py:    copy_kwargs = copy.copy(kwargs)
./botocore/config.py:        config_vars = copy.copy(self.OPTION_DEFAULTS)
./botocore/config.py:        config_options = copy.copy(self._user_provided_options)
./botocore/configprovider.py:        config_store = ConfigValueStore(copy.deepcopy(self._mapping, memo))
./botocore/configprovider.py:        config_store = ConfigValueStore(copy.copy(self._mapping))
./botocore/configprovider.py:            chain_provider_copy = copy.deepcopy(original_provider)
./botocore/configprovider.py:        section_provider_copy = copy.deepcopy(
./botocore/configprovider.py:            copy.deepcopy(self._providers, memo), self._conversion_func
./botocore/configprovider.py:            copy.deepcopy(self._instance_var, memo), self._session
./botocore/configprovider.py:            copy.deepcopy(self._config_var_name, memo), self._session
./botocore/configprovider.py:            copy.deepcopy(self._name, memo), copy.deepcopy(self._env, memo)
./botocore/configprovider.py:            copy.deepcopy(self._section_name, memo),
./botocore/configprovider.py:            copy.deepcopy(self._override_providers, memo),
./botocore/configprovider.py:        return ConstantProvider(copy.deepcopy(self._value, memo))
./botocore/regions.py:        customized_builtins = copy.copy(self._builtins)
./botocore/session.py:    SESSION_VARIABLES = copy.copy(BOTOCORE_DEFAUT_SESSION_VARIABLES)
./botocore/session.py:        return copy.copy(self._session_instance_vars)
./botocore/session.py:        config_store = copy.copy(self.get_component('config_store'))
./botocore/session.py:        self._store = copy.copy(session_vars)
./botocore/stub.py:            response = copy.copy(service_response)
./botocore/translate.py:        '__default__': copy.deepcopy(retry_model.get('__default__', {}))
./botocore/args.py:        event_emitter = copy.copy(self._event_emitter)
./botocore/configloader.py:    parsed_config = copy.deepcopy(parsed_ini_config)
./botocore/handlers.py:    request_dict_copy = copy.deepcopy(request_dict)
./botocore/hooks.py:        first_copy = copy.copy(self.first)
./botocore/hooks.py:        middle_copy = copy.copy(self.middle)
./botocore/hooks.py:        last_copy = copy.copy(self.last)
./botocore/hooks.py:        new_state['_handlers'] = copy.copy(self._handlers)
./botocore/hooks.py:        new_state['_unique_id_handlers'] = copy.copy(self._unique_id_handlers)
./botocore/hooks.py:            copy.copy(self._emitter), copy.copy(self._event_aliases)
./botocore/hooks.py:        # We can't use copy.deepcopy because we actually only want to copy
./botocore/hooks.py:                copied_node[key] = copy.copy(value)
./s3transfer/copies.py:            return copy.copy(copy_source)
./s3transfer/futures.py:            return copy.copy(self._associated_futures)
./s3transfer/manager.py:            return copy.copy(self._tracked_transfer_coordinators)
./s3transfer/tasks.py:        kwargs = copy.copy(self._main_kwargs)
grep: ./boto3/dynamodb/__pycache__/transform.cpython-312.pyc: binary file matches
./boto3/dynamodb/transform.py:    `copy.deepcopy()` when every instance of a repeated object in the deepcopied
./boto3/dynamodb/transform.py:    return copy.deepcopy(params, memo=_ForgetfulDict())
./boto3/resources/collection.py:        self._params = copy.deepcopy(kwargs)
./boto3/resources/collection.py:        params = copy.deepcopy(self._params)
./boto3/s3/inject.py:    new_config = python_copy.copy(config)
./boto3/s3/inject.py:    new_config = python_copy.copy(config)
./boto3/session.py:                config = copy.deepcopy(config)
./matplotlib/lines.py:        self._xorig = copy.copy(x)
./matplotlib/lines.py:        self._yorig = copy.copy(y)
./matplotlib/widgets.py:            event = copy.copy(event)
./matplotlib/font_manager.py:        return copy.copy(self)
./matplotlib/gridspec.py:            subplotpars = copy.copy(figure.subplotpars)
./matplotlib/_mathtext.py:        return copy.copy(self)
./matplotlib/path.py:        return copy.copy(self)
./matplotlib/path.py:        p = copy.deepcopy(super(), memo)
./matplotlib/markers.py:            self.__dict__ = copy.deepcopy(marker.__dict__)
./matplotlib/transforms.py:        other = copy.copy(super())
./matplotlib/transforms.py:        known state of a transform where ``copy.deepcopy()`` might normally be
./matplotlib/backends/qt_editor/_formlayout.py:        self.data = copy.deepcopy(data)
./matplotlib/tests/test_textpath.py:    assert copy.deepcopy(tp).vertices is not tp.vertices
./matplotlib/tests/test_textpath.py:    assert (copy.deepcopy(tp).vertices == tp.vertices).all()
./matplotlib/tests/test_textpath.py:    assert copy.copy(tp).vertices is tp.vertices
./matplotlib/tests/test_transforms.py:        s1 = copy.copy(s)
./matplotlib/tests/test_transforms.py:        b1 = copy.copy(b)
./matplotlib/tests/test_transforms.py:        s1 = copy.deepcopy(s)
./matplotlib/tests/test_transforms.py:        b1 = copy.deepcopy(b)
./matplotlib/tests/test_figure.py:    fig2 = copy.deepcopy(fig1)
./matplotlib/tests/test_backend_qt.py:    init_figs = copy.copy(Gcf.figs)
./matplotlib/tests/test_colors.py:    copied_cmap = copy.copy(cmap)
./matplotlib/tests/test_colors.py:    cmap2 = copy.copy(copied_cmap)
./matplotlib/tests/test_colors.py:    cmap2 = copy.copy(copied_cmap)
./matplotlib/tests/test_colors.py:    cmap = copy.copy(mpl.colormaps['viridis'])
./matplotlib/tests/test_colors.py:    norm2 = copy.deepcopy(norm)
./matplotlib/tests/test_colors.py:    norm2 = copy.deepcopy(norm)
./matplotlib/tests/test_scale.py:    sc2 = copy.deepcopy(sc)
./matplotlib/tests/test_rcparams.py:            copy.deepcopy(mpl.rcParams)
grep: ./matplotlib/__pycache__/transforms.cpython-312.pyc: binary file matches
./scipy/integrate/_quad_vec.py:        interval_cache[(x1, x2)] = copy.copy(ig)
./scipy/optimize/tests/test__basinhopping.py:        minimizer_kwargs = copy.copy(self.kwargs)
./scipy/optimize/tests/test__basinhopping.py:        minimizer_kwargs = copy.copy(self.kwargs_nograd)
./scipy/optimize/_shgo_lib/_complex.py:        a_vo = copy.copy(list(origin))
./scipy/optimize/_shgo_lib/_complex.py:                ab_Cc = copy.copy(ab_C)
./scipy/optimize/_shgo_lib/_complex.py:                    ab_Cc = copy.copy(ab_C)
./scipy/optimize/_shgo_lib/_complex.py:            cbounds = copy.copy(self.bounds)
./scipy/optimize/_shgo_lib/_complex.py:            tvs = copy.copy(self.triangulated_vectors)
./scipy/optimize/_shgo_lib/_complex.py:        origin_c = copy.copy(origin)
./scipy/optimize/_shgo_lib/_complex.py:        supremum_c = copy.copy(supremum)
./scipy/optimize/_shgo_lib/_complex.py:        sup_set = copy.copy(vco.nn)
./scipy/optimize/_shgo_lib/_complex.py:        a_vl = copy.copy(list(vot))
./scipy/optimize/_shgo_lib/_complex.py:            sup_set = copy.copy(vco.nn)
./scipy/optimize/_shgo_lib/_complex.py:            a_vl = copy.copy(list(vot))
./scipy/optimize/_shgo_lib/_complex.py:                ab_Cc = copy.copy(ab_C)  # NOTE: We append ab_C in the
./scipy/optimize/_shgo_lib/_complex.py:                s_ab_Cc = copy.copy(s_ab_C)
./scipy/optimize/_shgo_lib/_complex.py:        vnn = copy.copy(v.nn)
./scipy/optimize/_shgo_lib/_complex.py:            v1nn.append(copy.copy(v1.nn))
./scipy/optimize/_shgo_lib/_complex.py:        cvn_pool = copy.copy(vn_pool)
./scipy/_lib/_docscrape.py:        self._parsed_data = copy.deepcopy(self.sections)
./scipy/_lib/cobyqa/problem.py:                    c = copy.copy(constraint)
./scipy/sparse/linalg/_eigen/tests/test_svds.py:        rng_2 = copy.deepcopy(rng)
./scipy/sparse/linalg/_dsolve/linsolve.py:    A_new = copy.copy(A)
./scipy/stats/_qmc.py:        self.rng_seed = copy.deepcopy(self.rng)
./scipy/stats/_qmc.py:        rng = copy.deepcopy(self.rng_seed)
./scipy/stats/tests/test_multicomp.py:        samples_ = copy.deepcopy(samples)
./scipy/stats/tests/test_multicomp.py:        control_ = copy.deepcopy(control)
./scipy/stats/tests/test_multicomp.py:        samples_ = copy.deepcopy(samples)
./scipy/signal/_ltisys.py:        return copy.deepcopy(self)
./scipy/signal/_ltisys.py:        return copy.deepcopy(self)
./scipy/signal/_ltisys.py:        return copy.deepcopy(self)
./scipy/signal/tests/test_peak_finding.py:    gaps = copy.deepcopy(gaps)
./scipy/signal/tests/test_peak_finding.py:    distances = copy.deepcopy(distances)
./scipy/spatial/tests/test_qhull.py:        xd = copy.deepcopy(x.get_voronoi_diagram())
./scipy/spatial/tests/test_qhull.py:        yd = copy.deepcopy(y.get_voronoi_diagram())
./scipy/spatial/tests/test_qhull.py:        xd2 = copy.deepcopy(x.get_voronoi_diagram())
./scipy/spatial/tests/test_qhull.py:        yd2 = copy.deepcopy(y.get_voronoi_diagram())
./scipy/spatial/transform/tests/test_rotation.py:    r1 = copy.deepcopy(r)
./pyparsing/core.py:        cpy = copy.copy(self)
./pyparsing/core.py:    # Needed to make copy.copy() work correctly if we customize __new__
./pyparsing/core.py:                            return prev_loc, copy.copy(prev_result)
./pyparsing/core.py:                        return prev_loc, copy.copy(prev_peek)
./pyparsing/exceptions.py:        return copy.copy(self)
./pyarrow/vendored/docscrape.py:        self._parsed_data = copy.deepcopy(self.sections)
./google/protobuf/internal/containers.py:        copy.deepcopy(self._message_listener), self._type_checker)
./google/auth/_refresh_worker.py:                self._worker = RefreshThread(cred=cred, request=copy.deepcopy(request))
./google/auth/external_account.py:            "service_account_impersonation_options": copy.deepcopy(
./google/auth/external_account.py:            "credential_source": copy.deepcopy(self._credential_source),
./google/auth/impersonated_credentials.py:        self._source_credentials = copy.copy(source_credentials)
./google/auth/jwt.py:        new_additional_claims = copy.deepcopy(self._additional_claims)
./google/auth/jwt.py:        new_additional_claims = copy.deepcopy(self._additional_claims)
./google/oauth2/service_account.py:            scopes=copy.copy(self._scopes),
./google/oauth2/service_account.py:            default_scopes=copy.copy(self._default_scopes),
./google/oauth2/service_account.py:        new_additional_claims = copy.deepcopy(self._additional_claims)
./google/cloud/storage/blob.py:        return copy.deepcopy(self._properties.get("metadata"))
./google/cloud/storage/blob.py:        return copy.deepcopy(self._properties.get("owner"))
./google/cloud/storage/bucket.py:            query_params = copy.deepcopy(blob._query_params)
./google/cloud/storage/bucket.py:        return [copy.deepcopy(policy) for policy in self._properties.get("cors", ())]
./google/cloud/storage/bucket.py:        return copy.deepcopy(labels)
./google/cloud/storage/bucket.py:        self._patch_property("labels", copy.deepcopy(mapping))
./google/cloud/storage/bucket.py:        return copy.deepcopy(info)
./google/cloud/storage/bucket.py:        return copy.deepcopy(self._properties.get("owner"))
./google/api_core/path_template.py:        leftovers = copy.deepcopy(transcoded_value)
./google/api_core/protobuf_helpers.py:        original = copy.deepcopy(modified)
./google/api_core/protobuf_helpers.py:        modified = copy.deepcopy(original)
./fontTools/designspaceLib/__init__.py:            res = copy.deepcopy(self)
./fontTools/feaLib/builder.py:                            location, copy.deepcopy(markClassDef.anchor)
./fontTools/otlLib/builder.py:        table = self.buildLookup_(copy.deepcopy(subtables))
./fontTools/ttLib/tables/otTables.py:                    clips[glyph] = copy.copy(rec.ClipBox)
./fontTools/ufoLib/__init__.py:                        fs.copy.copy_fs(origFS, parentFS)
./fontTools/ufoLib/__init__.py:            fs.copy.copy_dir(reader.fs, sourcePath, self.fs, destPath)
./fontTools/ufoLib/__init__.py:            fs.copy.copy_file(reader.fs, sourcePath, self.fs, destPath)
./fontTools/ufoLib/__init__.py:                fs.copy.copy_fs(self.fs, destFS.makedir(rootDir))
./fontTools/varLib/merger.py:                class2Records.append(copy.deepcopy(rec2))
./fontTools/varLib/merger.py:                new.Value[i] = copy.deepcopy(val_rec)
./fontTools/varLib/merger.py:                new.Value[i] = copy.deepcopy(val_rec)
./fontTools/varLib/merger.py:                            layer = copy.deepcopy(layer)
./cycler/__init__.py:            self._left = [copy.copy(v) for v in left]
./cycler/__init__.py:        old_self = copy.copy(self)
./cycler/__init__.py:        old_self = copy.copy(self)
./werkzeug/local.py:        this happens with ``copy.copy``, which does
./werkzeug/local.py:    __copy__ = _ProxyLookup(copy.copy)
./werkzeug/local.py:    __deepcopy__ = _ProxyLookup(copy.deepcopy)
grep: ./werkzeug/__pycache__/local.cpython-312.pyc: binary file matches
./jinja2/runtime.py:        # do not implement the protocol being probed for. e.g., copy.copy(Undefined())
./gunicorn/config.py:        return copy.copy(self)
./docker/models/containers.py:    for key in copy.copy(kwargs):
./docker/models/containers.py:    for key in copy.copy(kwargs):
./docker/models/services.py:    for key in copy.copy(kwargs):
./docker/models/services.py:    for key in copy.copy(kwargs):
./docker/models/services.py:    for key in copy.copy(kwargs):
./docker/models/services.py:    for key in copy.copy(kwargs):
./pydantic/_internal/_utils.py:    Use copy.deepcopy() for non-empty collections and unknown objects.
grep: ./pydantic/_internal/__pycache__/_utils.cpython-312.pyc: binary file matches
./pydantic/v1/dataclasses.py:        return DataclassProxy(copy.copy(self.__dataclass__))
./pydantic/v1/dataclasses.py:        return DataclassProxy(copy.deepcopy(self.__dataclass__, memo))
./pydantic/v1/fields.py:                field_info = copy.copy(field_info)
./pydantic/v1/utils.py:    Use copy.deepcopy() for non-empty collections and unknown objects
grep: ./pydantic/v1/__pycache__/utils.cpython-312.pyc: binary file matches
./graphene/types/tests/test_definition.py:    query_type_copy = copy.copy(schema.graphql_schema.query_type)
./databricks/sdk/config.py:        cpy: Config = copy.copy(self)
./databricks/sdk/config.py:        cpy._user_agent_other_info = copy.deepcopy(self._user_agent_other_info)
./databricks/sdk/config.py:        return copy.deepcopy(self)
./databricks/sdk/useragent.py:    return copy.deepcopy(_extra)
./mlflow/models/evaluation/default_evaluator.py:            eval_fn_args.append(copy.deepcopy(self.aggregate_metrics))
./mlflow/models/evaluation/default_evaluator.py:                    eval_fn_args.append(copy.deepcopy(self.metrics_values))
./mlflow/models/evaluation/default_evaluator.py:                    copy.deepcopy(self.metrics_values),
./mlflow/models/evaluation/default_evaluator.py:        eval_df = pd.DataFrame({"prediction": copy.deepcopy(prediction)})
./mlflow/models/evaluation/default_evaluator.py:                return copy.deepcopy(self._data)
./mlflow/pyspark/optuna/storage.py:            frozen = copy.deepcopy(template_trial)
./mlflow/transformers/__init__.py:        model_config = copy.deepcopy(dict(self.model_config))
./mlflow/utils/gorilla.py:                    self.settings = copy.deepcopy(value)
./mlflow/utils/gorilla.py:        settings_ = copy.deepcopy(settings)
./pycparser/ply/cpp.py:                    macro.value[i] = copy.copy(macro.value[i])
./pycparser/ply/cpp.py:        rep = [copy.copy(_x) for _x in macro.value]
./pycparser/ply/cpp.py:            rep[i] = copy.copy(rep[i])
./pycparser/ply/cpp.py:                        ex = self.expand_macros([copy.copy(_x) for _x in m.value],expanded)
./pycparser/ply/cpp.py:                tokens[i] = copy.copy(t)
./pycparser/ply/cpp.py:                tokens[i] = copy.copy(t)
./pycparser/ply/lex.py:        c = copy.copy(self)
./proto/message.py:            mapping = copy.deepcopy(mapping)
./proto/message.py:            mapping = copy.copy(mapping)
./proto/marshal/collections/repeated.py:        canary = copy.deepcopy(self.pb).add()
./azure/core/pipeline/policies/_base.py:        self.http_request: HTTPRequestType = copy.deepcopy(http_request)
./azure/core/pipeline/transport/_base.py:            data = copy.deepcopy(self.body, memo)
./azure/core/pipeline/transport/_base.py:            files = copy.deepcopy(self.files, memo)
./azure/core/pipeline/transport/_base.py:            return copy.copy(self)
./azure/core/rest/_helpers.py:        request._multipart_mixed_info = copy.deepcopy(  # pylint: disable=protected-access
./azure/core/rest/_rest_py3.py:            request._data = copy.deepcopy(self._data, memo)
./azure/core/rest/_rest_py3.py:            request._files = copy.deepcopy(self._files, memo)
./azure/core/rest/_rest_py3.py:            return copy.copy(self)
./oauthlib/oauth2/rfc6749/endpoints/metadata.py:        claims = copy.deepcopy(self.initial_claims)
./databricks_cli/pipelines/api.py:        settings = copy.deepcopy(settings)
./databricks_cli/sdk/api_client.py:            tmp_headers = copy.deepcopy(self.default_headers)
./databricks_cli/unity_catalog/utils.py:    cmd_copy = copy.copy(cmd)
./mlflow_export_import-1.2.0.dist-info/entry_points.txt:copy-model-version = mlflow_export_import.copy.copy_model_version:main
./mlflow_export_import-1.2.0.dist-info/entry_points.txt:copy-run = mlflow_export_import.copy.copy_run:main
(venv) sagemaker-user@default:~/f1_ai_mlops_baseline/venv/lib/python3.12/site-packages$ 
